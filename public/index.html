<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hyperliquid BTC Perp Tracker</title>
    <meta name="theme-color" content="#0f1218" />
    <link rel="preload" href="/styles.css" as="style" />
    <link rel="stylesheet" href="/styles.css" />
  </head>
  <body>
    <div class="wrap">
      <header class="site-header">
        <h1>Hyperliquid BTC Perp Tracker</h1>
        <div class="row" style="align-items:center; gap:12px;">
          <div class="small muted">BTC: <span id="btcPrice">-</span></div>
          <div class="small muted">IP: <a href="#" id="ipInfoLink" aria-label="Refresh IP and region">-</a></div>
        </div>
      </header>

      <div class="card" aria-labelledby="addressEntryTitle">
        <div class="row" style="align-items:flex-start;">
          <div style="display:flex; flex-direction:column; gap:6px;">
            <label class="small muted" id="addressEntryTitle" for="addrInput">Add a Hyperliquid address</label>
            <div class="row">
              <input id="addrInput" type="text" placeholder="0x..." autocomplete="off" inputmode="text" aria-label="Hyperliquid address" />
              <button id="addBtn" aria-label="Add address to tracking list">Add address</button>
            </div>
            <span id="addMsg" class="muted small" role="status" aria-live="polite"></span>
          </div>
        </div>
      </div>

      <div class="card" aria-labelledby="positionsTitle">
        <h3 id="positionsTitle" style="margin:0 0 8px">Current Positions (BTC)</h3>
        <table style="width:100%;">
          <thead>
            <tr>
              <th class="sortable" data-sort="address">Address</th>
              <th class="sortable" data-sort="side">Side</th>
              <th class="sortable" data-sort="size">Size</th>
              <th class="sortable" data-sort="entry">Entry</th>
              <th class="sortable" data-sort="lev">Lev</th>
              <th class="sortable" data-sort="liq">Liq</th>
              <th class="sortable" data-sort="pnl">PnL</th>
              <th class="sortable" data-sort="updated">Updated</th>
            </tr>
          </thead>
          <tbody id="positionsTbody"></tbody>
        </table>
      </div>

      <div class="card" aria-labelledby="tradesTitle">
        <div class="flex space-between mb-2 trades-header">
          <h3 id="tradesTitle" style="margin:0">BTC Fills (All Tracked)</h3>
          <div class="trades-controls">
            <div class="control-field">
              <label class="small muted" for="timeModeSel">Time</label>
              <select id="timeModeSel">
                <option value="absolute">Absolute</option>
                <option value="relative" selected>Relative</option>
              </select>
            </div>
            <div class="control-field grow">
              <label class="small muted" for="tradesAddressFilter">Address</label>
              <select id="tradesAddressFilter" aria-label="Filter fills by address">
                <option value="">All addresses</option>
              </select>
            </div>
            <div class="control-actions">
              <button id="clearAllBtn" aria-label="Delete all stored trades without backfilling">üóëÔ∏è Clear</button>
              <button id="refreshAllBtn" class="btn-primary" aria-label="Clear all stored trades then fetch fresh fills for all addresses">üîÑ Refresh All</button>
            </div>
          </div>
        </div>
        <table style="width:100%;">
          <thead>
            <tr>
              <th class="sortable" data-sort="time">Time</th>
              <th class="sortable" data-sort="taddr">Address</th>
              <th class="sortable" data-sort="action">Action</th>
              <th class="sortable" data-sort="tsize">Size</th>
              <th class="sortable" data-sort="start">Start Position</th>
              <th class="sortable" data-sort="price">Price</th>
              <th class="sortable" data-sort="cpnl">Closed PnL</th>
            </tr>
          </thead>
          <tbody id="tradesTbody"></tbody>
        </table>
      </div>
    </div>

    <script type="module">
      import { mergeTrades, canLoadMore } from './app.js';
  const addrInput = document.getElementById('addrInput');
      const addBtn = document.getElementById('addBtn');
      const addMsg = document.getElementById('addMsg');
      const positionsTbody = document.getElementById('positionsTbody');
      const tradesTbody = document.getElementById('tradesTbody');
      const tradesAddressFilter = document.getElementById('tradesAddressFilter');
  const refreshAllBtn = document.getElementById('refreshAllBtn');
  const clearAllBtn = document.getElementById('clearAllBtn');
  // Infinite scroll sentinel
  const tradeSentinel = document.createElement('div');
  tradeSentinel.id = 'tradeSentinel';
  tradeSentinel.className = 'sentinel';
  tradeSentinel.innerHTML = '<span class="small muted">Loading more‚Ä¶</span>';
  document.querySelector('.card[aria-labelledby="tradesTitle"]').appendChild(tradeSentinel);
      const timeModeSel = document.getElementById('timeModeSel');
      const btcPriceSpan = document.getElementById('btcPrice');
      const ipInfoLink = document.getElementById('ipInfoLink');
      let posSort = { key: 'updated', dir: 'desc' };
      let tradeSort = { key: 'time', dir: 'desc' };
  let tradesState = { items: [], nextCursor: null, loadingMore: false, observer: null, rate: { lastAt: 0 }, latestSeq: 0, addressFilter: '' };
      // Toast system
      const toastContainer = document.createElement('div');
      toastContainer.className = 'toast-container';
      document.body.appendChild(toastContainer);
      function showToast(message, opts = {}) {
        const t = document.createElement('div');
        t.className = 'toast ' + (opts.type || '');
        t.innerHTML = `<span>${escapeHtml(message)}</span><span class="close-btn" aria-label="Close">‚úï</span>`;
        const close = () => { t.style.opacity = '0'; setTimeout(()=> t.remove(), 220); };
        t.querySelector('.close-btn').addEventListener('click', close);
        toastContainer.appendChild(t);
        setTimeout(close, opts.ttl || 4200);
      }
      let nickMap = {};
      let knownAddresses = [];
      let timeMode = 'relative';
  let refreshing = false;
      let relativeTimeTimer = null;

      const normalizeAddress = (addr) => (typeof addr === 'string' ? addr.trim().toLowerCase() : '');

      async function refreshNicknames() {
        try {
          const r = await fetch('/api/addresses');
          const data = await r.json();
          const addrList = Array.isArray(data.addresses) ? data.addresses : [];
          const nicknames = data.nicknames || {};
          const normalizedBook = {};
          Object.keys(nicknames).forEach((key) => {
            const norm = normalizeAddress(key);
            if (norm) normalizedBook[norm] = String(nicknames[key]);
          });
          nickMap = normalizedBook;
          const seen = new Set();
          knownAddresses = [];
          addrList.forEach((addr) => {
            const display = String(addr || '').trim();
            const norm = normalizeAddress(display);
            if (!norm || seen.has(norm)) return;
            seen.add(norm);
            knownAddresses.push({ value: norm, label: display });
          });
          renderAddressFilterOptions();
          renderTrades(tradesState.items);
        } catch (e) {
          console.warn('failed to refresh nicknames', e);
        }
      }

      function renderAddressFilterOptions() {
        if (!tradesAddressFilter) return;
        const current = tradesState.addressFilter || '';
        const exists = !current || knownAddresses.some((entry) => entry.value === current);
        tradesAddressFilter.innerHTML = '';
        const defaultOpt = document.createElement('option');
        defaultOpt.value = '';
        defaultOpt.textContent = 'All addresses';
        tradesAddressFilter.appendChild(defaultOpt);
        knownAddresses.forEach(({ value, label }) => {
          const opt = document.createElement('option');
          opt.value = value;
          const nick = nickMap[value];
          opt.textContent = nick ? `${nick} (${label})` : label || value;
          tradesAddressFilter.appendChild(opt);
        });
        tradesAddressFilter.value = exists ? current : '';
        if (!exists && current) {
          tradesState.addressFilter = '';
          tradesAddressFilter.value = '';
          void loadInitialTrades(300);
        }
      }

      async function fetchPositions() {
        const r = await fetch('/api/current-positions');
        return (await r.json()).positions || [];
      }

      async function fetchAllTrades(limit = 1000, cursor = null, address = null) {
        const url = new URL('/api/latest-trades', location.origin);
        url.searchParams.set('limit', limit);
        if (cursor?.beforeAt) url.searchParams.set('beforeAt', cursor.beforeAt);
        if (cursor?.beforeId != null) url.searchParams.set('beforeId', cursor.beforeId);
        if (address) url.searchParams.set('address', address);
        const r = await fetch(url.toString());
        const j = await r.json();
        const nextCursor = j.nextCursor || (j.nextBeforeAt ? { beforeAt: j.nextBeforeAt, beforeId: j.nextBeforeId ?? null } : null);
        return { trades: j.trades || [], nextCursor };
      }

      async function fetchPrice() {
        const r = await fetch('/api/price');
        return await r.json();
      }

      async function loadInitialTrades(limit = 300) {
        if (!tradeSentinel) return;
        tradesState.loadingMore = true;
        tradeSentinel.classList.add('loading');
        tradeSentinel.innerHTML = '<span class="small muted">Loading fills‚Ä¶</span>';
        showSkeletonRows();
        try {
          const { trades, nextCursor } = await fetchAllTrades(limit, null, tradesState.addressFilter || null);
          tradesState.items = trades;
          tradesState.nextCursor = nextCursor;
          renderTrades(tradesState.items);
          updateTradeSentinelIdle();
          initInfiniteScroll();
        } catch (e) {
          console.error('initial trades load failed', e);
          showToast('Failed to load fills', { type: 'error' });
        } finally {
          tradesState.loadingMore = false;
          tradeSentinel.classList.remove('loading');
          removeSkeletonRows();
        }
      }

      function updateTradeSentinelIdle() {
        if (!tradeSentinel) return;
        if (tradesState.nextCursor) {
          tradeSentinel.innerHTML = '<span class="small muted">Loading more‚Ä¶</span>';
          return;
        }
        const suffix = tradesState.addressFilter ? ' for this address' : '';
        if (tradesState.items.length === 0) {
          tradeSentinel.innerHTML = `<span class="small muted">No fills${suffix}</span>`;
        } else {
          tradeSentinel.innerHTML = `<span class="small muted">No more fills${suffix}</span>`;
        }
      }

      function refreshRelativeTradeTimes() {
        if (timeMode !== 'relative') return;
        document.querySelectorAll('td.trade-time[data-time]').forEach((td) => {
          const iso = td.getAttribute('data-time');
          if (iso) td.textContent = formatTime(iso);
        });
      }

      function ensureRelativeTimeTicker() {
        if (relativeTimeTimer) return;
        relativeTimeTimer = setInterval(() => {
          refreshRelativeTradeTimes();
        }, 30000);
      }
      ensureRelativeTimeTicker();

      async function applyAddressFilter(value) {
        const normalized = normalizeAddress(value);
        if (tradesState.addressFilter === normalized) return;
        tradesState.addressFilter = normalized;
        await loadInitialTrades(300);
      }

      function renderPositions(positions) {
        positions = sortPositions(positions);
        positionsTbody.innerHTML = '';
        positions.forEach(p => {
          const tr = document.createElement('tr');
          const sideTxt = p.side === 'long' ? '<span class="tag long">Long</span>' : (p.side === 'short' ? '<span class="tag short">Short</span>' : 'Flat');
          const sizeTxt = Math.abs(Number(p.size || 0)).toFixed(4);
          const entryTxt = p.entryPriceUsd ? formatUsd(Number(p.entryPriceUsd)) : '-';
          const levTxt = p.leverage ? (Number(p.leverage).toFixed(1) + 'x') : '-';
          const liqTxt = p.liquidationPriceUsd ? formatUsd(Number(p.liquidationPriceUsd)) : '-';
          const pnlNum = (typeof p.pnlUsd === 'number' && isFinite(p.pnlUsd)) ? p.pnlUsd : null;
          const pnlTxt = pnlNum !== null ? formatUsd(pnlNum) : '-';
          const pnlClass = pnlNum !== null ? (pnlNum >= 0 ? 'score positive' : 'score negative') : '';
          const displayName = p.nickname ? `<strong>${escapeHtml(p.nickname)}</strong><div class="small muted">${p.address}</div>` : `<span class="addr">${p.address}</span>`;
          tr.innerHTML = `
            <td>
              <a href="#" class="addr" data-address="${p.address}">${displayName}</a>
              <div class="small">
                <a href="#" data-action="edit-nick" data-address="${p.address}" data-nick="${p.nickname || ''}">Nickname</a>
                <span class="muted"> ¬∑ </span>
                <a href="#" data-action="remove" data-address="${p.address}">Remove</a>
              </div>
            </td>
            <td>${sideTxt}</td>
            <td>${sizeTxt}</td>
            <td>${entryTxt}</td>
            <td>${levTxt}</td>
            <td>${liqTxt}</td>
            <td class="${pnlClass}">${pnlTxt}</td>
            <td class="small muted">${formatTime(p.updatedAt)}</td>
          `;
          tr.querySelector('a[data-address]')?.addEventListener('click', (e) => { e.preventDefault(); showHoldings(p.address); });
          tr.querySelector('a[data-action="remove"]')?.addEventListener('click', async (e) => { e.preventDefault(); await removeAddress(p.address); await refresh(); await refreshNicknames(); });
          tr.querySelector('a[data-action="edit-nick"]')?.addEventListener('click', async (e) => { e.preventDefault(); await editNickname(p.address, p.nickname || ''); await refresh(); await refreshNicknames(); });
          // Add external Hyperbot link in actions
          (function(){ return;
            const actions = tr.querySelector('td .small');
            if (!actions) return;
            const sep = document.createElement('span');
            sep.className = 'muted';
            sep.textContent = ' ¬∑ ';
            const link = document.createElement('a');
            link.href = `https://hyperbot.network/trader/${encodeURIComponent(p.address)}`;
            link.target = '_blank';
            link.rel = 'noopener';
            link.textContent = 'Hyperbot ‚Üó';
            actions.appendChild(sep);
            actions.appendChild(link);
          })();
          positionsTbody.appendChild(tr);
        });
      }

      function renderTrades(trades) {
        trades = sortTrades(trades);
        tradesTbody.innerHTML = '';
        trades.forEach(t => {
          const tr = document.createElement('tr');
          const pnl = (typeof t.closedPnl === 'number' && isFinite(t.closedPnl)) ? t.closedPnl : null;
          const pnlTxt = pnl !== null ? formatUsd(pnl) : '-';
          const pnlClass = pnl !== null ? (pnl >= 0 ? 'score positive' : 'score negative') : '';
          const addrKey = normalizeAddress(t.address);
          const nick = addrKey && nickMap ? nickMap[addrKey] : null;
          const addrText = t.address || addrKey || '-';
          const addrHtml = nick
            ? (`<strong>${escapeHtml(nick)}</strong><div class="small muted">${addrText}</div>`)
            : `<span class="addr">${addrText}</span>`;
          tr.innerHTML = `
            <td class="small muted trade-time" data-time="${t.time || ''}">${formatTime(t.time)}</td>
            <td>${addrHtml}</td>
            <td>${escapeHtml(t.action || '')}</td>
            <td>${Number(t.size).toFixed(5)}</td>
            <td>${Number(t.startPosition ?? 0).toFixed(5)}</td>
            <td>${formatUsd(Number(t.price))}</td>
            <td class="${pnlClass}">${pnlTxt}</td>
          `;
          tradesTbody.appendChild(tr);
        });
        refreshRelativeTradeTimes();
        updateTradeSentinelIdle();
      }

      function sortPositions(positions) {
        const k = posSort.key, d = posSort.dir === 'asc' ? 1 : -1;
        const get = {
          address: p => p.address,
          side: p => ({ long: 1, short: -1, flat: 0 })[p.side] || 0,
          size: p => Number(p.size) || 0,
          entry: p => Number(p.entryPriceUsd) || -Infinity,
          lev: p => Number(p.leverage) || 0,
          liq: p => Number(p.liquidationPriceUsd) || -Infinity,
          pnl: p => Number(p.pnlUsd) || -Infinity,
          updated: p => new Date(p.updatedAt).getTime(),
        }[k] || ((p)=>0);
        return positions.slice().sort((a,b)=>{
          const av = get(a), bv = get(b);
          if (av < bv) return -1*d; if (av > bv) return 1*d; return 0;
        });
      }
      function sortTrades(trades) {
        const k = tradeSort.key, d = tradeSort.dir === 'asc' ? 1 : -1;
        const get = {
          time: t => new Date(t.time).getTime(),
          taddr: t => t.address,
          action: t => t.action,
          tsize: t => Number(t.size) || 0,
          start: t => Number(t.startPosition) || 0,
          price: t => Number(t.price) || 0,
          cpnl: t => Number(t.closedPnl) || 0,
        }[k] || ((t)=>0);
        return trades.slice().sort((a,b)=>{
          const av = get(a), bv = get(b);
          if (av < bv) return -1*d; if (av > bv) return 1*d; return 0;
        });
      }

      async function refresh() {
        try {
          const positions = await fetchPositions();
          renderPositions(positions);
        } catch (e) {
          console.error('refresh failed', e);
        }
      }

      async function fullRefreshAllFills() {
        if (refreshing) return;
        refreshing = true;
        refreshAllBtn.disabled = true;
        refreshAllBtn.textContent = '‚è≥ Refreshing...';
        try {
          // Step 1: clear all trades and backfill for all addresses
          const resp = await fetch('/api/clear-and-backfill-all', { method: 'POST', headers: { 'Content-Type': 'application/json' } });
          const j = await resp.json().catch(()=>({}));
          if (resp.ok) {
            showToast(`Cleared ${j.deleted || 0}, backfilled ${Object.values(j.perAddress||{}).reduce((a,v)=>a+v.inserted,0)} fills`, { type: 'success' });
          } else {
            showToast('Refresh action failed', { type: 'error' });
          }
          await loadInitialTrades(500);
        } catch (e) {
          console.error('full refresh failed', e);
          showToast('Failed to refresh fills', { type: 'error' });
        } finally {
          refreshing = false;
          refreshAllBtn.disabled = false;
          refreshAllBtn.textContent = 'üîÑ Refresh All';
        }
      }

      async function clearAllFillsOnly() {
        if (refreshing) return;
        refreshing = true;
        clearAllBtn.disabled = true;
        clearAllBtn.textContent = '‚è≥ Clearing...';
        try {
          if (!confirm('Delete ALL stored fills? This cannot be undone.')) { throw new Error('cancelled'); }
          const r = await fetch('/api/clear-all-trades', { method: 'POST' });
          const j = await r.json().catch(()=>({}));
          if (!r.ok) throw new Error('clear failed');
          tradesState.items = [];
          tradesState.nextCursor = null;
          renderTrades([]);
          updateTradeSentinelIdle();
          showToast(`Deleted ${j.deleted || 0} fills from DB`, { type: 'success' });
        } catch (e) {
          console.error('clear all fills failed', e);
          if (String(e.message) === 'cancelled') {
            showToast('Clear cancelled', { type: 'error', ttl: 1800 });
          } else {
            showToast('Failed to clear fills', { type: 'error' });
          }
        } finally {
          refreshing = false;
          clearAllBtn.disabled = false;
          clearAllBtn.textContent = 'üóëÔ∏è Clear';
        }
      }

      async function loadMoreFills() {
        if (tradesState.loadingMore) return;
        if (!tradesState.nextCursor) {
          updateTradeSentinelIdle();
          if (tradesState.observer) tradesState.observer.disconnect();
          return;
        }
        // Rate limit to prevent rapid triggering
        if (!canLoadMore(tradesState.rate, 800)) return;
        tradesState.loadingMore = true;
        tradeSentinel.classList.add('loading');
        tradeSentinel.innerHTML = '<span class="small muted">Loading more‚Ä¶</span>';
        showSkeletonRows();
        try {
          const { trades, nextCursor } = await fetchAllTrades(200, tradesState.nextCursor, tradesState.addressFilter || null);
          if (trades.length === 0) {
            tradesState.nextCursor = null;
            updateTradeSentinelIdle();
            if (tradesState.observer) tradesState.observer.disconnect();
            showToast('Reached oldest fills', { type: 'success', ttl: 2500 });
          } else {
            const beforeCount = tradesState.items.length;
            tradesState.items = mergeTrades(tradesState.items, trades);
            const newCount = Math.max(0, tradesState.items.length - beforeCount);
            tradesState.nextCursor = nextCursor;
            renderTrades(tradesState.items);
            showToast(`Loaded ${newCount} older fills`, { type: 'success' });
            updateTradeSentinelIdle();
          }
        } catch (e) {
          console.error('load more failed', e);
          showToast('Failed to load more fills', { type: 'error' });
          tradeSentinel.innerHTML = '<span class="small muted">Load error ‚Äì retry scrolling</span>';
        } finally {
          tradesState.loadingMore = false;
          tradeSentinel.classList.remove('loading');
          removeSkeletonRows();
        }
      }

      function initInfiniteScroll() {
        if (tradesState.observer) tradesState.observer.disconnect();
        const opts = { root: null, rootMargin: '0px', threshold: 0.1 };
        tradesState.observer = new IntersectionObserver((entries) => {
          for (const e of entries) {
            if (e.isIntersecting) {
              loadMoreFills();
            }
          }
        }, opts);
        tradesState.observer.observe(tradeSentinel);
      }

      function showSkeletonRows(count = 6) {
        removeSkeletonRows();
        for (let i=0;i<count;i++) {
          const tr = document.createElement('tr');
          tr.className = 'skeleton-row';
          for (let c=0;c<7;c++) {
            const td = document.createElement('td');
            const sk = document.createElement('span');
            sk.className = 'skeleton';
            td.appendChild(sk);
            tr.appendChild(td);
          }
          tradesTbody.appendChild(tr);
        }
      }
      function removeSkeletonRows() {
        document.querySelectorAll('.skeleton-row').forEach(r=>r.remove());
      }

      // Accessibility: aria-live regions
      toastContainer.setAttribute('aria-live','polite');
      toastContainer.setAttribute('role','status');
      tradeSentinel.setAttribute('aria-live','polite');

      async function refreshPrice() {
        try {
          const p = await fetchPrice();
          const price = p && typeof p.price === 'number' ? p.price : null;
          if (price && isFinite(price)) {
            btcPriceSpan.textContent = formatUsd(Number(price));
          }
        } catch (e) {}
      }

      async function refreshIpDisplay() {
        try {
          const r = await fetch('/api/ipinfo');
          const j = await r.json();
          const ip = j && typeof j.ip === 'string' ? j.ip : '-';
          const region = j && typeof j.region === 'string' ? j.region : null;
          const country = j && typeof j.country === 'string' ? j.country : null;
          const city = j && typeof j.city === 'string' ? j.city : null;
          let suffix = '';
          if (city && country) suffix = `${city}, ${country}`;
          else if (country) suffix = country;
          else if (region) suffix = region;
          ipInfoLink.textContent = suffix ? `${ip} (${suffix})` : ip;
          ipInfoLink.title = 'Click to refresh IP via server';
        } catch (e) {
          ipInfoLink.textContent = '-';
        }
      }

      addBtn.addEventListener('click', async () => {
        const address = (addrInput.value || '').trim();
        addMsg.textContent = '';
        if (!address) return;
        try {
          const r = await fetch('/api/addresses', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ address })
          });
          if (!r.ok) {
            const j = await r.json().catch(() => ({}));
            addMsg.textContent = j.error || 'Failed to add address';
            return;
          }
          addrInput.value = '';
          addMsg.textContent = 'Added';
          setTimeout(() => (addMsg.textContent = ''), 1200);
          await refresh();
          await refreshNicknames();
        } catch (e) {
          addMsg.textContent = 'Network error';
        }
      });

      // IP refresh click (server-originated call)
      if (ipInfoLink) {
        ipInfoLink.addEventListener('click', async (e) => {
          e.preventDefault();
          try {
            ipInfoLink.textContent = '‚Ä¶';
            await fetch('/api/ipinfo/refresh', { method: 'POST' });
          } catch (e) { /* ignore */ }
          await refreshIpDisplay();
        });
      }

      async function removeAddress(address) {
        await fetch(`/api/addresses/${encodeURIComponent(address)}`, { method: 'DELETE' });
      }

      async function editNickname(address, currentNick) {
        const next = prompt('Set nickname for address', currentNick || '');
        if (next === null) return; // cancelled
        await fetch(`/api/addresses/${encodeURIComponent(address)}/nickname`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ nickname: next })
        });
      }

      // Modal for holdings (per address)
      const modal = document.createElement('div');
      modal.className = 'modal-overlay';
      const modalCard = document.createElement('div');
      modalCard.className = 'modal-card';
      modalCard.innerHTML = '<div class="row" style="justify-content:space-between; align-items:center; margin-bottom:8px;"><div id="modalHeader" class="row" style="gap:8px; align-items:center;"><strong>Perp holdings</strong><a id="modalHyperbot" href="#" target="_blank" rel="noopener" class="small" style="text-decoration:underline;">Open in Hyperbot ‚Üó</a></div><button id="modalClose" aria-label="Close holdings modal">Close</button></div><div id="modalBody" class="small"></div>';
      modal.appendChild(modalCard);
      document.body.appendChild(modal);
      document.getElementById('modalClose').addEventListener('click', () => { modal.style.display = 'none'; });

      async function showHoldings(address) {
        modal.style.display = 'flex';
        const hbLink = modal.querySelector('#modalHyperbot');
        if (hbLink) hbLink.setAttribute('href', 'https://hyperbot.network/trader/' + encodeURIComponent(address));
        const body = modal.querySelector('#modalBody');
        body.textContent = 'Loading...';
        try {
          const r = await fetch(`/api/positions/${encodeURIComponent(address)}`);
          const j = await r.json();
          const positions = j.positions || [];
          if (!positions.length) {
            body.textContent = 'No open perp positions.';
            return;
          }
          const tbl = document.createElement('table');
          tbl.style.width = '100%';
          tbl.style.borderCollapse = 'collapse';
          tbl.innerHTML = '<thead><tr><th>Symbol</th><th>Side</th><th>Size</th><th>Entry</th><th>Lev</th></tr></thead>';
          const tb = document.createElement('tbody');
          positions.forEach(p => {
            const tr = document.createElement('tr');
            const side = p.size > 0 ? 'Long' : 'Short';
            tr.innerHTML = `
              <td>${p.symbol}</td>
              <td>${side}</td>
              <td>${Math.abs(p.size).toFixed(4)}</td>
              <td>${p.entryPriceUsd ? formatUsd(Number(p.entryPriceUsd)) : '-'}</td>
              <td>${p.leverage ? Number(p.leverage).toFixed(1) + 'x' : '-'}</td>
            `;
            Array.from(tr.children).forEach(td => td.style.padding = '6px');
            tb.appendChild(tr);
          });
          tbl.appendChild(tb);
          body.innerHTML = '';
          body.appendChild(tbl);
        } catch (e) {
          body.textContent = 'Failed to load holdings.';
        }
      }

      // Sorting handlers
      document.querySelectorAll('#positionsTitle ~ table thead th.sortable').forEach(th => {
        th.addEventListener('click', () => {
          const key = th.getAttribute('data-sort');
          if (posSort.key === key) posSort.dir = posSort.dir === 'asc' ? 'desc' : 'asc';
          else { posSort.key = key; posSort.dir = 'desc'; }
          fetchPositions().then(renderPositions).catch(()=>{});
        });
      });
      document.querySelectorAll('#tradesTitle ~ table thead th.sortable').forEach(th => {
        th.addEventListener('click', () => {
          const key = th.getAttribute('data-sort');
          if (tradeSort.key === key) tradeSort.dir = tradeSort.dir === 'asc' ? 'desc' : 'asc';
          else { tradeSort.key = key; tradeSort.dir = 'desc'; }
          renderTrades(tradesState.items);
        });
      });

  // Refresh, clear & pagination handlers
  refreshAllBtn.addEventListener('click', fullRefreshAllFills);
  clearAllBtn.addEventListener('click', clearAllFillsOnly);
  // Infinite scroll initialization after first load handled below

      // Initial load and polling
      refresh();
      setInterval(refresh, 5000);
      refreshPrice();
      setInterval(refreshPrice, 3000);
      // Initial IP info + periodic UI refresh (server fetch interval is independent)
      refreshIpDisplay();
      setInterval(refreshIpDisplay, 60000);
      // Initial trades load (current stored trades)
  (async () => {
    await refreshNicknames();
    await loadInitialTrades(300);
  })();
  // Real-time WebSocket client
  let ws; let wsRetry = 0;
  function connectWS() {
    const proto = location.protocol === 'https:' ? 'wss' : 'ws';
    ws = new WebSocket(`${proto}://${location.host}/ws`);
    ws.addEventListener('open', () => { wsRetry = 0; ws.send(JSON.stringify({ since: tradesState.latestSeq || 0 })); });
    ws.addEventListener('message', (e) => {
      try {
        const msg = JSON.parse(e.data);
        if (msg.type === 'events' || msg.type === 'batch') {
          const evs = msg.events || [];
          let tradeAdditions = [];
          for (const ev of evs) {
            if (ev.type === 'trade') {
              const normAddr = normalizeAddress(ev.address);
              if (tradesState.addressFilter && normAddr !== tradesState.addressFilter) {
                continue;
              }
              tradeAdditions.push({
                id: ev.dbId ?? ev.seq,
                time: ev.at,
                address: ev.address,
                action: ev.action || (ev.side === 'buy' ? 'Buy' : 'Sell'),
                size: ev.size,
                startPosition: ev.startPosition ?? null,
                price: ev.priceUsd,
                closedPnl: ev.realizedPnlUsd ?? null,
                tx: ev.hash ?? null,
              });
            }
          }
          if (tradeAdditions.length) {
            const beforeCount = tradesState.items.length;
            tradesState.items = mergeTrades(tradesState.items, tradeAdditions);
            // Only re-render the new items at top for efficiency
            renderTrades(tradesState.items);
            const newCount = tradesState.items.length - beforeCount;
            if (newCount > 0) {
              // Flash first few new rows
              const rows = tradesTbody.querySelectorAll('tr');
              for (let i=0; i<Math.min(newCount, 5); i++) {
                rows[i]?.classList.add('flash-new');
              }
            }
          }
          if (evs.length) { tradesState.latestSeq = evs[evs.length - 1].seq; }
        }
      } catch (err) { /* ignore */ }
    });
    ws.addEventListener('close', () => {
      const timeout = Math.min(1000 * Math.pow(2, wsRetry), 15000);
      wsRetry += 1;
      setTimeout(connectWS, timeout);
    });
    ws.addEventListener('error', () => { try { ws.close(); } catch {}; });
  }
  connectWS();
      if (timeModeSel) timeModeSel.value = timeMode;
      timeModeSel.addEventListener('change', () => { timeMode = timeModeSel.value; renderTrades(tradesState.items); });
      if (tradesAddressFilter) {
        tradesAddressFilter.addEventListener('change', async () => {
          await applyAddressFilter(tradesAddressFilter.value || '');
        });
      }

      function formatUsd(n) {
        if (typeof n !== 'number' || !isFinite(n)) return '-';
        try {
          return '$' + n.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
        } catch { return '$' + n.toFixed(2); }
      }
      function formatTime(iso) {
        if (!iso) return '-';
        const d = new Date(iso);
        if (timeMode === 'relative') {
          const diffMs = Date.now() - d.getTime();
          const sec = Math.round(diffMs / 1000);
          const min = Math.round(sec / 60);
          const hr = Math.round(min / 60);
          const day = Math.round(hr / 24);
          if (sec < 60) return `${sec}s ago`;
          if (min < 60) return `${min}m ago`;
          if (hr < 24) return `${hr}h ago`;
          return `${day}d ago`;
        }
        return d.toLocaleString();
      }
      function escapeHtml(s) {
        return String(s).replace(/[&<>"']/g, function(c){
          switch (c) {
            case '&': return '&amp;';
            case '<': return '&lt;';
            case '>': return '&gt;';
            case '"': return '&quot;';
            default: return '&#39;';
          }
        });
      }
    </script>
  </body>
  </html>
